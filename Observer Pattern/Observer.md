## Observer

ناظر یک الگوی رفتاری است که تغییرات رخ داده شده در یک کلاس توسط چند کلاس مورد مشاهده قرار می گیرد. فرض کنید یک فروشگاه وجود دارد که محصولات مختلف را به فروش می رساند مشتری های این فروشگاه دنبال محصولات متنوعی هستند به عنوان مثال دنبال مدل جدید آیفون هستند اگر فروشگاه آیفون مدل جدید را موجود کند و به همه کارابران اطلاع دهد این کار اشتباهی است باید تنها به مشتریانی اطلاع دهد که به مدل جدید آیفون علاقمند هستند برایا اینکار از الگوی ناظر استفاده می شود.

کلاسی که ما می خواهیم تغییرات آن را مورد بررسی قرار دهیم اغلب اوقات subject نامیده می شود. کلاس های دیگری که می خواهند این تغییرات را متوجه بشوند subscribeنامیده می شوند. الگوی ناظر به شما نشان می دهد که یک سیستم اشتراک به کلاس اصلی اضافه کنید تا بقیه کلاس ها اگر خواستند در تغییرات آن مشترک شوند یا لغو اشتراک بزنند. نگران نباشید این موضوع پیچیده نیست تنها یک لیست که کلاس های مشترک را ذخیره می کند و متود های برای حذف و اضافه کردن کلاس های مشترک.

## Head First Design Pattern

یک دستگاه هواشناسی وجود دارد که اطلاعاتی مانند دما، رطوبت هوا، فشار هوا را اندازه گیری می کند. چند دستگاه نمایشگر وجود دارد که اطلاعات این دستگاه هواشناسی را نمایش می دهد. در نمونه اولیه پیاده سازی به نحو زیر است:

```php
<?php

namespace App\Http\Controllers\SolveOne;

class WeatherDataClass
{
    public function getTemp(): string
    {
        return rand(10, 40) . " C";
    }

    public function getPressure(): string
    {
        return rand(1, 10) . ' g';
    }

    public function getHumidity(): string
    {
        return rand(0, 100) . ' %';
    }

    public function showDataInMultiDisplay()
    {
        $temp = $this->getTemp();
        $pressure = $this->getPressure();
        $humidity = $this->getHumidity();

        (new DisplayOne())->display($temp, $pressure, $humidity);
        (new DisplayTwo())->display($temp, $pressure, $humidity);
        (new DisplayThree())->display($temp, $pressure, $humidity);
    }
}
```

این روش پیاده سازی چندین مشکل دارد که عبارتند از:

1-بدون تغییر در کلاس WeatherDataClass امکان اضافه کردن نمایشگر دیگر وجود ندارد.

2-در حین اجرا امکان حذف یا اضافه کردن نمایشگر دیگر وجود ندارد.

```
Publishe + Subscriber ==> Observer Patterns
```

Subject دارنده داده است و هر گاه داده تغییر کند به Observer اطلاع رسانی می کند با اینکار به نوعی داده بین چند شی تقسیم می شود.

#### Loosley Coupled

در observer pattern اشیا با یکدیگر ارتباط سست دارند و در مورد یکدیگر اطلاعات کمی دارند. موارد زیر باعث ایجاد ارتباط سست شده است:

1-تنها چیزی که Subject در مورد Observerمی داند این نکته است که از یک اینترفیس مشخص ارث بری میکند.

2-شما می توانید هر تعداد Observerمورد نیاز اضافه کنید.

3-برای اضافه کردن Observer جدید نیاز به تغییر کد ندارید.

4- شما می توانید از Observer یا Subject استفاده مجدد کنید زیرا این ها به صورت محکم به هم وابسته نیستند.

اتصال سست به دلیل عدم وابستگی برای هندل کردن تغییرات به ما کمک فراوانی می کند.

