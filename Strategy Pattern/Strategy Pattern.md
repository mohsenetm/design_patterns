## Intent

این دیزاین پترن در Behavioure Design Pattern است.

تعریف خانواده ای از الگوریتم ها، کپسوله کردن هر کدام از آن ها(محدود کردن دسترسی به اجزای هر یک از شی ها)، دادن قابلیت تعویض آن ها با یکدیگر. این دیزاین پترن باعث می شود گه یک الگوریتم کاملا مستقل از کلاینت وظیفه خود را انجام دهد.(تعریف گنگ آو فور)

تعریف خانواده ای از الگوریتم ها که هر کدام از آن ها را درون یککلاس جدا قرار می دهیم این کلاس ها قابلیت جایگزینی با یکدیگر را دارند.(Refactoring Guru)

استلزام خانواده ای از الگوریتم ها برای ارث بری از یک اینترفیس مشخص و ارسال این الگوریتم ها به متود سازنده کلاس هایی که از این الگوریتم ها استفاده می کنند.



## Example

یک شبیه ساز اردک وجود دارد که به اردک ها قابلیت پرواز کردن می خواهد اضافه شود

#### Solve One

در حالت اول ارث بری استفاده شده است و خوب متود پرواز را هم به کلاس پدر اضافه می شود.

مشکل اردک پلاستیکی پرواز می کند.

مشکلاتی که این کار بوجود می آورد:

1-باید متود ها را درکلاس های بسیاری باز نویسی کرد.

2-اگر رفتار جدید به کلاس پدر اضافه شود باید همه کلاس های فرزند مورد بازنگری قرار بگیرد.

3-اگر همه رفتار توسط پدر پیاده سازی شود بررسی رفتار یک کلاس دشوار خواهد بود.

#### Problem Solve Two

استفاده از اینترفیس

یک کابوس به تمام معنا، باید در همه کلاس ها نحوه پیاده سازی متودها را بیان کرد.

#### Solve

انتقال رفتار به کلاس هایی به نام استراتژی که از یک اینترفیس استفاده می کنند. این رفتار ها در متود سازنده کلاس اردک ازشون شی ساخته می شود.

## How To Implement

1-در کلاس اصلی الگوریتمی که تغییرات بسیار زیادی دارد را مشخص می کنید.

2-یک اینترفیس را برای همه کلاس های استراتژی بیان می کنید.

3-همه کلاس ها استراتژی باید از این اینترفیس ارث بری کنند و بنابراین تابع الگوریتم را پیاده سازی کنند.

4-در کلاس اصلی یک متغیر برا ذخیره شی الگوریتم ایجاد کنید. می توانید از setter برای تغییر استراتژی استفاده کنید. کلاس اصلی تنها می داند که این الگوریتم از استراتژی اینترفیس ارث بری می کند. کلاس اصلی می تواند یک رابط تعریف کند که استراتژی ها بتوانند با استفاده از آن به اطلاعات کلاس اصلی دسترسی داشته باشند.

5-کلاینت باید کلاس اصلی با استراتژی های که کار ما ار انجام می دهد مرتبط کرد.



## Pros

شما می توانید الگوریتم موجود در یک آبجکت را حین اجرا به راحتی عوض کنید.

پنهان سازی نحوه پیاده سازی الگوریتم از کلاینت

استفاده از ادغام به جای ارث بری

رعایت اصل open/close

## Cons

کلاینت باید نوع استراتژی را بداند بنابراین قبل از استفاده از استراتژی ها تفاوت آن ها را کلاینت بداند.

فرستادن اطلاعات اضافی به کلاینت ها

ساختن اشیا زیاد.

شما الگوریتم های محدودی دارید و این الگوریتم ها به ندرت تغییر می کنند واقعا نیاز نیست از این دیزاین پترن استفاده کنید.



## Practice

#### Practice One

فرض کنید شما می خواهید یک نرم افزار راهنمای مسیریابی برای رانندگان طراحی کنید. مهم ترین اصل در این نرم افزار پیاده سازی یک سیستم مسیریابی است که کاربر با وارد کردن مبدا و مقصد سریع ترین مسیر ممکن را پیدا کند. در ورژن اولیه نرم افزار این مسیر یابی را با استفاده از مسیر جاده ای انجام می دهید.

در ورژن های بعدی شما روش های جدیدی برای حمل و نقل پیشنهاد می کنید مثلا مسیریابی با استفاده از دوچرخه یا وسایل حمل و نقل عمومی. این اضافه کردن ویژگی های جدید باعث می شود حجم کد شما بسیار زیاد شود.

#### Practice Two

الگوریتم های متفاوتی برای شکستن یک رشته متن به چندین خط وجود دارد.کلاینت نیاز به شکستن خطوط دارد و نمی خواهد درگیر کد شکستن خطوط شود. برای کلاینت سخت تر و دشوار تر خواهد بود اگر بخواهد از چندین روش برای شکستن خطوط پشتیبانی کند. هر کدام از این الگوریتم ها برای زمان های گوناگون مورد نیاز هستند بنابراین نمی خواهیم از همه آن ها پشتیبانی کنیم. اضافه کردن یک الگوریتم خیلی سخت خواهد بود وقتی الگوریتم ها قسمتی از کلاینت باشند.